# Опросник по проекту AI Contact Form

## Сколько времени занимала каждая часть?

- **Настройка проекта и базовая конфигурация**: ~30 минут
  - Создание Next.js проекта с TypeScript
  - Установка зависимостей (Supabase, Zod, Playwright, Tailwind)
  - Настройка environment variables

- **Настройка Supabase и схема базы данных**: ~20 минут
  - Создание проекта в Supabase
  - Разработка схемы (таблицы users и submissions)
  - Написание SQL миграций
  - Настройка клиента Supabase

- **API Routes**: ~45 минут
  - POST /api/submit (сохранение формы)
  - GET /api/submissions (получение истории)
  - POST /api/ai/improve (интеграция с Gemini)
  - GET /api/ai/usage (счетчик использования AI)
  - Валидация через Zod
  - Обработка ошибок

- **Компоненты UI**: ~60 минут
  - UserNamePrompt (модальное окно для ввода имени)
  - ContactForm (основная форма с валидацией)
  - AIImprover (улучшение сообщений через AI)
  - AIUsageCounter (отображение счетчика)
  - SubmissionsList (история отправок)

- **Тестирование Playwright**: ~30 минут
  - Настройка Playwright
  - Написание 5 E2E тестов
  - Отладка тестов

- **Документация**: ~15 минут
  - README.md с инструкциями
  - Комментарии в коде
  - Документация по Supabase setup

**Общее время**: ~3 часа 20 минут

## Какую базу данных вы выбрали и почему?

**Выбрана: Supabase (PostgreSQL)**

**Причины выбора:**
1. **Простота настройки**: Supabase предоставляет готовую PostgreSQL базу с UI для управления
2. **Бесплатный tier**: Достаточно для тестового проекта (500 MB хранилища, 50 MB файлов)
3. **Отличная документация**: Быстрый старт с примерами для Next.js
4. **TypeScript поддержка**: Автогенерация типов из схемы базы данных
5. **Real-time возможности**: Хотя в текущем проекте не используются, могут пригодиться для будущих фич
6. **Встроенная аутентификация**: Может быть полезна для расширения проекта
7. **Хорошая интеграция с Vercel**: Упрощает деплой

**Альтернативы, которые рассматривались:**
- **MongoDB Atlas**: Хорош для гибких схем, но для этого проекта реляционная БД более подходящая
- **PlanetScale**: Отличный вариант, но Supabase имеет более простой UI
- **Vercel Postgres**: Хорошая интеграция с Vercel, но Supabase предоставляет больше возможностей

## Какова схема вашей базы данных?

### Таблица: `users`
```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT UNIQUE NOT NULL,
    ai_usage_count INTEGER DEFAULT 0 NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
);

-- Индекс для быстрого поиска по имени
CREATE INDEX idx_users_name ON users(name);
```

**Поля:**
- `id`: UUID - уникальный идентификатор пользователя
- `name`: TEXT - имя пользователя из localStorage (уникальное)
- `ai_usage_count`: INTEGER - счетчик использования AI функции
- `created_at`: TIMESTAMP - дата создания записи

### Таблица: `submissions`
```sql
CREATE TABLE submissions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_name TEXT NOT NULL REFERENCES users(name) ON DELETE CASCADE,
    email TEXT NOT NULL,
    subject TEXT NOT NULL,
    message TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
);

-- Индекс для быстрого получения отправок пользователя
CREATE INDEX idx_submissions_user_name ON submissions(user_name);
-- Индекс для сортировки по дате
CREATE INDEX idx_submissions_created_at ON submissions(created_at DESC);
```

**Поля:**
- `id`: UUID - уникальный идентификатор отправки
- `user_name`: TEXT - имя пользователя (foreign key → users.name)
- `email`: TEXT - email из формы
- `subject`: TEXT - тема обращения
- `message`: TEXT - текст сообщения
- `created_at`: TIMESTAMP - дата отправки

**Связи:**
- `submissions.user_name` → `users.name` (ON DELETE CASCADE)
- При удалении пользователя автоматически удаляются все его отправки

**Индексы для оптимизации:**
- `idx_users_name` - быстрый поиск пользователя по имени
- `idx_submissions_user_name` - быстрое получение отправок конкретного пользователя
- `idx_submissions_created_at` - эффективная сортировка по дате

## Как работает улучшение искусственного интеллекта? (показать подсказку)

### Процесс улучшения:

1. **Пользователь вводит сообщение** в textarea
2. **Нажимает кнопку "✨ Улучшить с помощью AI"**
3. **Frontend отправляет POST запрос** на `/api/ai/improve` с телом:
   ```json
   {
     "message": "исходное сообщение пользователя",
     "userName": "имя пользователя"
   }
   ```
4. **Backend вызывает Gemini API** с промптом (см. ниже)
5. **Gemini возвращает улучшенную версию**
6. **Backend увеличивает счетчик** `ai_usage_count` в таблице users
7. **Frontend показывает preview** с исходным и улучшенным текстом
8. **Пользователь выбирает** "Использовать это" или "Отменить"

### Prompt для Gemini API:

```javascript
const prompt = `Ты помогаешь пользователю улучшить его сообщение, которое он отправляет в службу поддержки или контактную форму компании.

Перепиши следующее сообщение пользователя так, чтобы оно звучало более профессионально и понятно, но сохраняло тот же смысл и намерение. Исправь грамматические и орфографические ошибки. Сделай текст вежливым, но не слишком формальным. Сохрани точку зрения пользователя (от первого лица).

Исходное сообщение пользователя: ${message}

Верни только улучшенную версию сообщения без дополнительных комментариев или пояснений.`;
```

### Ключевые моменты промпта:

1. **Контекст**: Четко указано, что это сообщение пользователя в службу поддержки
2. **Сохранение смысла**: AI должен сохранить намерение и точку зрения пользователя
3. **Тон**: Профессионально, но не слишком формально
4. **Грамматика**: Исправление ошибок
5. **Формат ответа**: Только улучшенный текст, без пояснений
6. **От первого лица**: Важно сохранить, что это сообщение ОТ пользователя, а не ответ компании

### Пример работы:

**Вход:**
```
"мне нравится ваш продукт, но ему нужен темный режим!!!"
```

**Выход:**
```
"Мне действительно нравится пользоваться вашим продуктом! Я бы хотел, чтобы в будущем обновлении была добавлена опция темного режима."
```

### Обработка ошибок:

- **Timeout (30 секунд)**: "Сервис временно недоступен. Попробуйте позже."
- **Rate limit (429)**: "Превышен лимит запросов. Попробуйте позже."
- **Invalid API key (401)**: "AI сервис временно недоступен"
- **Generic error**: "Не удалось улучшить сообщение. Попробуйте позже."

## Что было самым сложным?

1. **Правильная формулировка промпта для Gemini**
   - Первая версия промпта приводила к тому, что AI отвечал как служба поддержки, а не улучшал сообщение пользователя
   - Решение: Добавил четкий контекст "Ты помогаешь пользователю улучшить ЕГО сообщение" и "Сохрани точку зрения пользователя (от первого лица)"

2. **Обработка race conditions в Supabase**
   - При одновременном создании пользователя и отправки могли возникать конфликты
   - Решение: Использовал `ON CONFLICT DO NOTHING` в SQL и проверку существования пользователя перед вставкой

3. **Real-time валидация формы**
   - Нужно было валидировать поля в реальном времени, но не показывать ошибки сразу
   - Решение: Валидация при onChange, но ошибки показываются только после blur или попытки отправки

4. **Playwright тесты с асинхронными операциями**
   - AI запросы могут занимать до 10-15 секунд
   - Решение: Увеличил timeout до 30 секунд для AI тестов и добавил явное ожидание API response

## Использовали ли вы помощников по программированию с помощью искусственного интеллекта?

**Да, использовал Kiro AI (AI-ассистент в IDE)**

### Для чего использовался:

1. **Генерация boilerplate кода**
   - Создание базовой структуры API routes
   - Генерация TypeScript типов
   - Создание Zod схем валидации

2. **Написание SQL миграций**
   - Создание таблиц с правильными типами данных
   - Добавление индексов для оптимизации
   - Настройка foreign keys и constraints

3. **Отладка и исправление ошибок**
   - Помощь в исправлении TypeScript ошибок
   - Отладка проблем с Supabase клиентом
   - Исправление промпта для Gemini API

4. **Написание тестов Playwright**
   - Генерация базовой структуры тестов
   - Помощь с селекторами и assertions
   - Обработка асинхронных операций

5. **Документация**
   - Помощь в написании README.md
   - Создание комментариев в коде
   - Форматирование markdown файлов

### Что делал вручную:

- Архитектурные решения (выбор БД, структура проекта)
- Дизайн UI/UX (расположение элементов, цвета, анимации)
- Логика бизнес-процессов
- Финальная отладка и тестирование
- Оптимизация промпта для Gemini

## Что бы вы сделали по-другому в рабочей среде?

### 1. Аутентификация и безопасность
- **Реальная аутентификация**: Использовал бы Supabase Auth или NextAuth.js вместо localStorage
- **Rate limiting**: Добавил бы ограничение на количество запросов к AI API (например, через Upstash Redis)
- **CSRF защита**: Добавил бы CSRF токены для форм
- **Input sanitization**: Более строгая очистка пользовательского ввода
- **API key rotation**: Механизм ротации API ключей

### 2. Производительность
- **Кэширование**: Redis для кэширования частых запросов
- **Database connection pooling**: Использовал бы connection pool для Supabase
- **CDN**: Статические ассеты через CDN (Cloudflare, Vercel Edge)
- **Image optimization**: Next.js Image component для оптимизации изображений
- **Code splitting**: Более агрессивное разделение кода

### 3. Мониторинг и логирование
- **Error tracking**: Sentry или LogRocket для отслеживания ошибок
- **Analytics**: Google Analytics или Plausible для аналитики
- **Performance monitoring**: Vercel Analytics или New Relic
- **Structured logging**: Winston или Pino для структурированных логов
- **Alerting**: Настройка алертов при критических ошибках

### 4. Тестирование
- **Unit тесты**: Jest для тестирования утилит и хуков
- **Integration тесты**: Тестирование API routes с mock базой данных
- **Component тесты**: React Testing Library для компонентов
- **Visual regression**: Percy или Chromatic для визуальных тестов
- **Load testing**: k6 или Artillery для нагрузочного тестирования

### 5. CI/CD
- **GitHub Actions**: Автоматический запуск тестов при PR
- **Automated deployment**: Автодеплой на staging при merge в develop
- **Preview deployments**: Vercel preview для каждого PR
- **Database migrations**: Автоматическое применение миграций
- **Rollback strategy**: Механизм быстрого отката при проблемах

### 6. Доступность (A11y)
- **ARIA labels**: Более полные ARIA атрибуты
- **Keyboard navigation**: Полная поддержка навигации с клавиатуры
- **Screen reader testing**: Тестирование с NVDA/JAWS
- **Color contrast**: Проверка контрастности через axe DevTools
- **Focus management**: Правильное управление фокусом в модальных окнах

### 7. Интернационализация
- **i18n**: next-intl или react-i18next для мультиязычности
- **Locale detection**: Автоопределение языка пользователя
- **RTL support**: Поддержка right-to-left языков
- **Date/time formatting**: Правильное форматирование дат для разных локалей

### 8. База данных
- **Migrations management**: Prisma или Drizzle ORM для управления миграциями
- **Backup strategy**: Автоматические бэкапы базы данных
- **Read replicas**: Использование read replicas для масштабирования
- **Query optimization**: Более детальная оптимизация запросов
- **Database monitoring**: Мониторинг производительности запросов

## Что бы вы добавили дальше?

### Краткосрочные улучшения (1-2 недели)

1. **Email уведомления**
   - Отправка подтверждения пользователю после отправки формы
   - Уведомление администратора о новой отправке
   - Использование Resend или SendGrid

2. **Расширенная история отправок**
   - Фильтрация по дате, теме
   - Поиск по содержимому сообщений
   - Пагинация для больших списков
   - Экспорт в CSV/PDF

3. **Улучшенный AI функционал**
   - Выбор тона сообщения (формальный, дружелюбный, краткий)
   - Перевод сообщения на другие языки
   - Проверка грамматики без полного переписывания
   - История AI улучшений с возможностью отката

4. **Dashboard для администратора**
   - Просмотр всех отправок
   - Статистика использования (графики, метрики)
   - Управление пользователями
   - Модерация сообщений

### Среднесрочные улучшения (1-2 месяца)

5. **Расширенная аналитика**
   - Тепловая карта использования AI
   - Анализ популярных тем обращений
   - Время ответа на обращения
   - Satisfaction score после решения проблемы

6. **Интеграции**
   - Slack/Discord уведомления для команды
   - Jira/Linear интеграция для создания тикетов
   - Zapier/Make.com для автоматизации
   - CRM интеграция (HubSpot, Salesforce)

7. **Улучшенный UX**
   - Drag & drop для прикрепления файлов
   - Автосохранение черновиков
   - Шаблоны сообщений
   - Быстрые ответы (FAQ)

8. **Мобильное приложение**
   - React Native приложение
   - Push уведомления
   - Offline режим с синхронизацией

### Долгосрочные улучшения (3+ месяца)

9. **AI-powered features**
   - Автоматическая категоризация обращений
   - Sentiment analysis (анализ тональности)
   - Предложение похожих решений из базы знаний
   - Chatbot для первичной поддержки

10. **Масштабирование**
    - Микросервисная архитектура
    - Message queue (RabbitMQ, Kafka) для обработки
    - Horizontal scaling с load balancer
    - Multi-region deployment

11. **Продвинутая безопасность**
    - Two-factor authentication
    - End-to-end encryption для сообщений
    - Audit logs для всех действий
    - Compliance с GDPR, CCPA

12. **Бизнес-функции**
    - Платные планы с разными лимитами AI
    - Team collaboration (несколько пользователей в одной организации)
    - Custom branding для enterprise клиентов
    - SLA гарантии для premium пользователей

---

## Использованные AI инструменты

- **Kiro AI**: Основной AI-ассистент для разработки
  - Генерация кода
  - Отладка
  - Написание тестов
  - Документация

## Время разработки

**Общее время**: ~3 часа 20 минут (в рамках лимита 3 часа по ТЗ + 20 минут на документацию)

## Заключение

Проект демонстрирует полный цикл разработки современного веб-приложения с использованием актуальных технологий (Next.js 15, React 19, TypeScript, Supabase, Gemini AI). Все требования ТЗ выполнены, включая обязательные тесты Playwright и документацию.
